#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License") you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   https:#www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#

# Code generated by code-generation. DO NOT EDIT.
from abc import ABC, abstractmethod
from dataclasses import dataclass



@dataclass
class ModbusADU(ABC, PlcMessage):
        # Arguments.
            response: Boolean



    def __post_init__(self):
super().__init__( )

    # Abstract accessors for discriminator values.
    @abstractmethod
    def getDriverType(self) -> DriverType:



    @abstractmethod
    def serializeModbusADUChild(writeBuffer: WriteBuffer) -> None:
        pass

    def serialize(self, writeBuffer: WriteBuffer):
        positionAware: PositionAware = writeBuffer
            startPos: int = positionAware.getPos()
            writeBuffer.pushContext("ModbusADU")

                        # Switch field (Serialize the sub-type)
                        serializeModbusADUChild(writeBuffer)

            writeBuffer.popContext("ModbusADU")


    def getLengthInBytes(self) -> int:
        return int(math.ceil(float(getLengthInBits() / 8.0)))

    def getLengthInBits(self) -> int:
        lengthInBits: int = 0
        _value: ModbusADU = self

        # Length of sub-type elements will be added by sub-type...

        return lengthInBits


    def staticParse(readBuffer: ReadBuffer , args) -> ModbusADU:
        positionAware: PositionAware = readBuffer
        if (args is None) or (args.length is not 2):
            raise PlcRuntimeException("Wrong number of arguments, expected 2, but got " + args.length)

        driverType: DriverType = None
        if isinstance(args[0], DriverType):
            driverType = DriverType(args[0])
        elif isinstance(args[0], String):
            driverType = DriverType.valueOf(str(args[0]))
        else:
            raise PlcRuntimeException("Argument 0 expected to be of type DriverType or a string which is parseable but was " + args[0].getClass().getName())

        response: Boolean = None
        if isinstance(args[1], Boolean):
            response = Boolean(args[1])
        elif isinstance(args[1], String):
            response = Boolean.valueOf(str(args[1]))
        else:
            raise PlcRuntimeException("Argument 1 expected to be of type Boolean or a string which is parseable but was " + args[1].getClass().getName())

        return staticParse(readBuffer, driverType, response)
    }

    def  staticParse(readBuffer: ReadBuffer, DriverType driverType, Boolean response) -> ModbusADU:
        readBuffer.pullContext("ModbusADU")
        positionAware: PositionAware = readBuffer
        startPos: int = positionAware.getPos()
        curPos: int = 0

                # Switch Field (Depending on the discriminator values, passes the instantiation to a sub-type)
                builder: ModbusADUBuilder = None
if EvaluationHelper.equals( driverType, DriverType.MODBUS_TCP ) ) :builder = ModbusTcpADU.staticParseBuilder(readBuffer, driverType, response)                     else:
if EvaluationHelper.equals( driverType, DriverType.MODBUS_RTU ) ) :builder = ModbusRtuADU.staticParseBuilder(readBuffer, driverType, response)                     else:
if:builder = ModbusAsciiADU.staticParseBuilder(readBuffer, driverType, response)                    
                if builder is None:
                    raise ParseException("Unsupported case for discriminated type"+" parameters ["+"driverType="+driverType+"]")


    readBuffer.closeContext("ModbusADU")
    # Create the instance
        _modbusADU: ModbusADU = builder.build(
            
                response
        )
        return _modbusADU

        class ModbusADUBuilder:
            def build(
            
                Boolean response
        ) -> ModbusADU:


    def equals(self, o: object) -> bool:
        if this == o:
            return True

        if not (instanceof(o, ModbusADU):
            return False

        that: ModbusADU = ModbusADU(o)
        return
            True

    def hashCode(self) -> int:
        return Objects.hash(
        )

    def toString(self) -> str:
        writeBufferBoxBased: WriteBufferBoxBased = WriteBufferBoxBased(true, true)
        try:
            writeBufferBoxBased.writeSerializable(this)
        except SerializationException:
            raise RuntimeException(e)

        return "\n" + writeBufferBoxBased.getBox().toString()+ "\n"


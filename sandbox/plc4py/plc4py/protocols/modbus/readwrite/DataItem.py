#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#

# Code generated by code-generation. DO NOT EDIT.

from abc import staticmethod
from ctypes import c_bool
from ctypes import c_double
from ctypes import c_float
from ctypes import c_int16
from ctypes import c_int32
from ctypes import c_int64
from ctypes import c_int8
from ctypes import c_uint16
from ctypes import c_uint32
from ctypes import c_uint64
from ctypes import c_uint8
from loguru import logging as log
from plc4py.protocols.modbus.readwrite.ModbusDataType import ModbusDataType
    

class DataItem:

    @staticmethod
    def static_parse(read_buffer: ReadBuffer, data_type: ModbusDataType, number_of_values: c_uint16):
        if EvaluationHelper.equals( data_type, ModbusDataType.BOOL ) and EvaluationHelper.equals( number_of_values, 1 ) :  # BOOL


            # Reserved Field (Compartmentalized so the "reserved" variable can't leak)

            reserved: c_uint16 = /*TODO: migrate me*//*TODO: migrate me*/read_buffer.readUnsignedInt("", 15);
            if reserved != (c_uint16) 0x0000:
                LOGGER.info("Expected constant value " + 0x0000 + " but got " + reserved + " for reserved field.");


            // Simple Field (value)
            c_bool value = /*TODO: migrate me*//*TODO: migrate me*/read_buffer.readBit("");

            return new PlcBOOL(value);
        } else         if EvaluationHelper.equals( data_type, ModbusDataType.BOOL ) :  # List

            # Array field (value)
            # Count array
            if numberOfValues > Integer.MAX_VALUE:
                raise ParseException("Array count of " + (numberOfValues) + " exceeds the maximum allowed count of " + Integer.MAX_VALUE)

            item_count: int = int(numberOfValues)
            value: List[PlcValue] = []
            for cur_item in range(item_count):
                value.append(PlcBOOL((c_bool) /*TODO: migrate me*//*TODO: migrate me*/read_buffer.readBit("")))


            return new PlcList(value);
        } else         if EvaluationHelper.equals( data_type, ModbusDataType.BYTE ) and EvaluationHelper.equals( number_of_values, 1 ) :  # BYTE


            # Reserved Field (Compartmentalized so the "reserved" variable can't leak)

            reserved: c_uint8 = /*TODO: migrate me*//*TODO: migrate me*/read_buffer.readUnsignedShort("", 8);
            if reserved != (c_uint8) 0x00:
                LOGGER.info("Expected constant value " + 0x00 + " but got " + reserved + " for reserved field.");


            // Simple Field (value)
            c_uint8 value = /*TODO: migrate me*//*TODO: migrate me*/read_buffer.readUnsignedShort("", 8);

            return new PlcBYTE(value);
        } else         if EvaluationHelper.equals( data_type, ModbusDataType.BYTE ) :  # List

            # Array field (value)
            # Count array
            if (numberOfValues) * (8) > Integer.MAX_VALUE:
                raise ParseException("Array count of " + ((numberOfValues) * (8)) + " exceeds the maximum allowed count of " + Integer.MAX_VALUE)

            item_count: int = int((numberOfValues) * (8))
            value: List[PlcValue] = []
            for cur_item in range(item_count):
                value.append(PlcBOOL((c_bool) /*TODO: migrate me*//*TODO: migrate me*/read_buffer.readBit("")))


            return new PlcList(value);
        } else         if EvaluationHelper.equals( data_type, ModbusDataType.WORD ) :  # WORD


            // Simple Field (value)
            c_uint16 value = /*TODO: migrate me*//*TODO: migrate me*/read_buffer.readUnsignedInt("", 16);

            return new PlcWORD(value);
        } else         if EvaluationHelper.equals( data_type, ModbusDataType.DWORD ) :  # DWORD


            // Simple Field (value)
            c_uint32 value = /*TODO: migrate me*//*TODO: migrate me*/read_buffer.readUnsignedLong("", 32);

            return new PlcDWORD(value);
        } else         if EvaluationHelper.equals( data_type, ModbusDataType.LWORD ) :  # LWORD


            // Simple Field (value)
            c_uint64 value = /*TODO: migrate me*//*TODO: migrate me*/read_buffer.readUnsignedBigInteger("", 64);

            return new PlcLWORD(value);
        } else         if EvaluationHelper.equals( data_type, ModbusDataType.SINT ) and EvaluationHelper.equals( number_of_values, 1 ) :  # SINT


            # Reserved Field (Compartmentalized so the "reserved" variable can't leak)

            reserved: c_uint8 = /*TODO: migrate me*//*TODO: migrate me*/read_buffer.readUnsignedShort("", 8);
            if reserved != (c_uint8) 0x00:
                LOGGER.info("Expected constant value " + 0x00 + " but got " + reserved + " for reserved field.");


            // Simple Field (value)
            c_int8 value = /*TODO: migrate me*//*TODO: migrate me*/read_buffer.readSignedByte("", 8);

            return new PlcSINT(value);
        } else         if EvaluationHelper.equals( data_type, ModbusDataType.SINT ) :  # List

            # Array field (value)
            # Count array
            if numberOfValues > Integer.MAX_VALUE:
                raise ParseException("Array count of " + (numberOfValues) + " exceeds the maximum allowed count of " + Integer.MAX_VALUE)

            item_count: int = int(numberOfValues)
            value: List[PlcValue] = []
            for cur_item in range(item_count):
                value.append(PlcSINT((c_int8) /*TODO: migrate me*//*TODO: migrate me*/read_buffer.readSignedByte("", 8)))


            return new PlcList(value);
        } else         if EvaluationHelper.equals( data_type, ModbusDataType.INT ) and EvaluationHelper.equals( number_of_values, 1 ) :  # INT


            // Simple Field (value)
            c_int16 value = /*TODO: migrate me*//*TODO: migrate me*/read_buffer.readShort("", 16);

            return new PlcINT(value);
        } else         if EvaluationHelper.equals( data_type, ModbusDataType.INT ) :  # List

            # Array field (value)
            # Count array
            if numberOfValues > Integer.MAX_VALUE:
                raise ParseException("Array count of " + (numberOfValues) + " exceeds the maximum allowed count of " + Integer.MAX_VALUE)

            item_count: int = int(numberOfValues)
            value: List[PlcValue] = []
            for cur_item in range(item_count):
                value.append(PlcINT((c_int16) /*TODO: migrate me*//*TODO: migrate me*/read_buffer.readShort("", 16)))


            return new PlcList(value);
        } else         if EvaluationHelper.equals( data_type, ModbusDataType.DINT ) and EvaluationHelper.equals( number_of_values, 1 ) :  # DINT


            // Simple Field (value)
            c_int32 value = /*TODO: migrate me*//*TODO: migrate me*/read_buffer.readInt("", 32);

            return new PlcDINT(value);
        } else         if EvaluationHelper.equals( data_type, ModbusDataType.DINT ) :  # List

            # Array field (value)
            # Count array
            if numberOfValues > Integer.MAX_VALUE:
                raise ParseException("Array count of " + (numberOfValues) + " exceeds the maximum allowed count of " + Integer.MAX_VALUE)

            item_count: int = int(numberOfValues)
            value: List[PlcValue] = []
            for cur_item in range(item_count):
                value.append(PlcDINT((c_int32) /*TODO: migrate me*//*TODO: migrate me*/read_buffer.readInt("", 32)))


            return new PlcList(value);
        } else         if EvaluationHelper.equals( data_type, ModbusDataType.LINT ) and EvaluationHelper.equals( number_of_values, 1 ) :  # LINT


            // Simple Field (value)
            c_int64 value = /*TODO: migrate me*//*TODO: migrate me*/read_buffer.readLong("", 64);

            return new PlcLINT(value);
        } else         if EvaluationHelper.equals( data_type, ModbusDataType.LINT ) :  # List

            # Array field (value)
            # Count array
            if numberOfValues > Integer.MAX_VALUE:
                raise ParseException("Array count of " + (numberOfValues) + " exceeds the maximum allowed count of " + Integer.MAX_VALUE)

            item_count: int = int(numberOfValues)
            value: List[PlcValue] = []
            for cur_item in range(item_count):
                value.append(PlcLINT((c_int64) /*TODO: migrate me*//*TODO: migrate me*/read_buffer.readLong("", 64)))


            return new PlcList(value);
        } else         if EvaluationHelper.equals( data_type, ModbusDataType.USINT ) and EvaluationHelper.equals( number_of_values, 1 ) :  # USINT


            # Reserved Field (Compartmentalized so the "reserved" variable can't leak)

            reserved: c_uint8 = /*TODO: migrate me*//*TODO: migrate me*/read_buffer.readUnsignedShort("", 8);
            if reserved != (c_uint8) 0x00:
                LOGGER.info("Expected constant value " + 0x00 + " but got " + reserved + " for reserved field.");


            // Simple Field (value)
            c_uint8 value = /*TODO: migrate me*//*TODO: migrate me*/read_buffer.readUnsignedShort("", 8);

            return new PlcUSINT(value);
        } else         if EvaluationHelper.equals( data_type, ModbusDataType.USINT ) :  # List

            # Array field (value)
            # Count array
            if numberOfValues > Integer.MAX_VALUE:
                raise ParseException("Array count of " + (numberOfValues) + " exceeds the maximum allowed count of " + Integer.MAX_VALUE)

            item_count: int = int(numberOfValues)
            value: List[PlcValue] = []
            for cur_item in range(item_count):
                value.append(PlcUINT((c_uint8) /*TODO: migrate me*//*TODO: migrate me*/read_buffer.readUnsignedShort("", 8)))


            return new PlcList(value);
        } else         if EvaluationHelper.equals( data_type, ModbusDataType.UINT ) and EvaluationHelper.equals( number_of_values, 1 ) :  # UINT


            // Simple Field (value)
            c_uint16 value = /*TODO: migrate me*//*TODO: migrate me*/read_buffer.readUnsignedInt("", 16);

            return new PlcUINT(value);
        } else         if EvaluationHelper.equals( data_type, ModbusDataType.UINT ) :  # List

            # Array field (value)
            # Count array
            if numberOfValues > Integer.MAX_VALUE:
                raise ParseException("Array count of " + (numberOfValues) + " exceeds the maximum allowed count of " + Integer.MAX_VALUE)

            item_count: int = int(numberOfValues)
            value: List[PlcValue] = []
            for cur_item in range(item_count):
                value.append(PlcUDINT((c_uint16) /*TODO: migrate me*//*TODO: migrate me*/read_buffer.readUnsignedInt("", 16)))


            return new PlcList(value);
        } else         if EvaluationHelper.equals( data_type, ModbusDataType.UDINT ) and EvaluationHelper.equals( number_of_values, 1 ) :  # UDINT


            // Simple Field (value)
            c_uint32 value = /*TODO: migrate me*//*TODO: migrate me*/read_buffer.readUnsignedLong("", 32);

            return new PlcUDINT(value);
        } else         if EvaluationHelper.equals( data_type, ModbusDataType.UDINT ) :  # List

            # Array field (value)
            # Count array
            if numberOfValues > Integer.MAX_VALUE:
                raise ParseException("Array count of " + (numberOfValues) + " exceeds the maximum allowed count of " + Integer.MAX_VALUE)

            item_count: int = int(numberOfValues)
            value: List[PlcValue] = []
            for cur_item in range(item_count):
                value.append(PlcULINT((c_uint32) /*TODO: migrate me*//*TODO: migrate me*/read_buffer.readUnsignedLong("", 32)))


            return new PlcList(value);
        } else         if EvaluationHelper.equals( data_type, ModbusDataType.ULINT ) and EvaluationHelper.equals( number_of_values, 1 ) :  # ULINT


            // Simple Field (value)
            c_uint64 value = /*TODO: migrate me*//*TODO: migrate me*/read_buffer.readUnsignedBigInteger("", 64);

            return new PlcULINT(value);
        } else         if EvaluationHelper.equals( data_type, ModbusDataType.ULINT ) :  # List

            # Array field (value)
            # Count array
            if numberOfValues > Integer.MAX_VALUE:
                raise ParseException("Array count of " + (numberOfValues) + " exceeds the maximum allowed count of " + Integer.MAX_VALUE)

            item_count: int = int(numberOfValues)
            value: List[PlcValue] = []
            for cur_item in range(item_count):
                value.append(PlcLINT((c_uint64) /*TODO: migrate me*//*TODO: migrate me*/read_buffer.readUnsignedBigInteger("", 64)))


            return new PlcList(value);
        } else         if EvaluationHelper.equals( data_type, ModbusDataType.REAL ) and EvaluationHelper.equals( number_of_values, 1 ) :  # REAL


            // Simple Field (value)
            c_float value = /*TODO: migrate me*//*TODO: migrate me*/read_buffer.readFloat("", 32);

            return new PlcREAL(value);
        } else         if EvaluationHelper.equals( data_type, ModbusDataType.REAL ) :  # List

            # Array field (value)
            # Count array
            if numberOfValues > Integer.MAX_VALUE:
                raise ParseException("Array count of " + (numberOfValues) + " exceeds the maximum allowed count of " + Integer.MAX_VALUE)

            item_count: int = int(numberOfValues)
            value: List[PlcValue] = []
            for cur_item in range(item_count):
                value.append(PlcREAL((c_float) /*TODO: migrate me*//*TODO: migrate me*/read_buffer.readFloat("", 32)))


            return new PlcList(value);
        } else         if EvaluationHelper.equals( data_type, ModbusDataType.LREAL ) and EvaluationHelper.equals( number_of_values, 1 ) :  # LREAL


            // Simple Field (value)
            c_double value = /*TODO: migrate me*//*TODO: migrate me*/read_buffer.readDouble("", 64);

            return new PlcLREAL(value);
        } else         if EvaluationHelper.equals( data_type, ModbusDataType.LREAL ) :  # List

            # Array field (value)
            # Count array
            if numberOfValues > Integer.MAX_VALUE:
                raise ParseException("Array count of " + (numberOfValues) + " exceeds the maximum allowed count of " + Integer.MAX_VALUE)

            item_count: int = int(numberOfValues)
            value: List[PlcValue] = []
            for cur_item in range(item_count):
                value.append(PlcLREAL((c_double) /*TODO: migrate me*//*TODO: migrate me*/read_buffer.readDouble("", 64)))


            return new PlcList(value);
        } else         if EvaluationHelper.equals( data_type, ModbusDataType.CHAR ) and EvaluationHelper.equals( number_of_values, 1 ) :  # CHAR


            // Simple Field (value)
            str value = /*TODO: migrate me*//*TODO: migrate me*/read_buffer.readString("", 8, "UTF-8");

            return new PlcCHAR(value);
        } else         if EvaluationHelper.equals( data_type, ModbusDataType.CHAR ) :  # List

            # Array field (value)
            # Count array
            if numberOfValues > Integer.MAX_VALUE:
                raise ParseException("Array count of " + (numberOfValues) + " exceeds the maximum allowed count of " + Integer.MAX_VALUE)

            item_count: int = int(numberOfValues)
            value: List[PlcValue] = []
            for cur_item in range(item_count):
                value.append(PlcSTRING((str) /*TODO: migrate me*//*TODO: migrate me*/read_buffer.readString("", 8, "UTF-8")))


            return new PlcList(value);
        } else         if EvaluationHelper.equals( data_type, ModbusDataType.WCHAR ) and EvaluationHelper.equals( number_of_values, 1 ) :  # WCHAR


            // Simple Field (value)
            str value = /*TODO: migrate me*//*TODO: migrate me*/read_buffer.readString("", 16, "UTF-16");

            return new PlcWCHAR(value);
        } else         if EvaluationHelper.equals( data_type, ModbusDataType.WCHAR ) :  # List

            # Array field (value)
            # Count array
            if numberOfValues > Integer.MAX_VALUE:
                raise ParseException("Array count of " + (numberOfValues) + " exceeds the maximum allowed count of " + Integer.MAX_VALUE)

            item_count: int = int(numberOfValues)
            value: List[PlcValue] = []
            for cur_item in range(item_count):
                value.append(PlcSTRING((str) /*TODO: migrate me*//*TODO: migrate me*/read_buffer.readString("", 16, "UTF-16")))


            return new PlcList(value);
        }
        return null;
    }

    public static void staticSerialize(WriteBuffer writeBuffer, PlcValue _value, ModbusDataType dataType, c_uint16 numberOfValues) throws SerializationException {
        staticSerialize(writeBuffer, _value, dataType, numberOfValues, ByteOrder.BIG_ENDIAN);
    }

    public static void staticSerialize(WriteBuffer writeBuffer, PlcValue _value, ModbusDataType dataType, c_uint16 numberOfValues, ByteOrder byteOrder) throws SerializationException {
if( EvaluationHelper.equals( dataType, ModbusDataType.BOOL ) && EvaluationHelper.equals( numberOfValues, 1 ) ) { // BOOL
            // Reserved Field
            /*TODO: migrate me*//*TODO: migrate me*/writeBuffer.writeUnsignedInt("", 15, ((Number) (c_uint16) 0x0000).intValue());
            // Simple Field (value)
            c_bool value = (c_bool) _value.getC_bool();
            /*TODO: migrate me*//*TODO: migrate me*/writeBuffer.writeBit("", (boolean) (value));
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.BOOL ) ) { // List
            PlcList values = (PlcList) _value;

            for (PlcValue val : ((List<PlcValue>) values.getList())) {
                c_bool value = (c_bool) val.getC_bool();
                /*TODO: migrate me*//*TODO: migrate me*/writeBuffer.writeBit("", (boolean) (value));
            }

        } else if( EvaluationHelper.equals( dataType, ModbusDataType.BYTE ) && EvaluationHelper.equals( numberOfValues, 1 ) ) { // BYTE
            // Reserved Field
            /*TODO: migrate me*//*TODO: migrate me*/writeBuffer.writeUnsignedShort("", 8, ((Number) (c_uint8) 0x00).shortValue());
            // Simple Field (value)
            c_uint8 value = (c_uint8) _value.getC_uint8();
            /*TODO: migrate me*//*TODO: migrate me*/writeBuffer.writeUnsignedShort("", 8, ((Number) (value)).shortValue());
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.BYTE ) ) { // List
            PlcList values = (PlcList) _value;

            for (PlcValue val : ((List<PlcValue>) values.getList())) {
                c_bool value = (c_bool) val.getC_bool();
                /*TODO: migrate me*//*TODO: migrate me*/writeBuffer.writeBit("", (boolean) (value));
            }

        } else if( EvaluationHelper.equals( dataType, ModbusDataType.WORD ) ) { // WORD
            // Simple Field (value)
            c_uint16 value = (c_uint16) _value.getC_uint16();
            /*TODO: migrate me*//*TODO: migrate me*/writeBuffer.writeUnsignedInt("", 16, ((Number) (value)).intValue());
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.DWORD ) ) { // DWORD
            // Simple Field (value)
            c_uint32 value = (c_uint32) _value.getC_uint32();
            /*TODO: migrate me*//*TODO: migrate me*/writeBuffer.writeUnsignedLong("", 32, ((Number) (value)).longValue());
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.LWORD ) ) { // LWORD
            // Simple Field (value)
            c_uint64 value = (c_uint64) _value.getC_uint64();
            /*TODO: migrate me*//*TODO: migrate me*/writeBuffer.writeUnsignedBigInteger("", 64, (BigInteger) (value));
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.SINT ) && EvaluationHelper.equals( numberOfValues, 1 ) ) { // SINT
            // Reserved Field
            /*TODO: migrate me*//*TODO: migrate me*/writeBuffer.writeUnsignedShort("", 8, ((Number) (c_uint8) 0x00).shortValue());
            // Simple Field (value)
            c_int8 value = (c_int8) _value.getC_int8();
            /*TODO: migrate me*//*TODO: migrate me*/writeBuffer.writeSignedByte("", 8, ((Number) (value)).byteValue());
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.SINT ) ) { // List
            PlcList values = (PlcList) _value;

            for (PlcValue val : ((List<PlcValue>) values.getList())) {
                c_int8 value = (c_int8) val.getC_int8();
                /*TODO: migrate me*//*TODO: migrate me*/writeBuffer.writeSignedByte("", 8, ((Number) (value)).byteValue());
            }

        } else if( EvaluationHelper.equals( dataType, ModbusDataType.INT ) && EvaluationHelper.equals( numberOfValues, 1 ) ) { // INT
            // Simple Field (value)
            c_int16 value = (c_int16) _value.getC_int16();
            /*TODO: migrate me*//*TODO: migrate me*/writeBuffer.writeShort("", 16, ((Number) (value)).shortValue());
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.INT ) ) { // List
            PlcList values = (PlcList) _value;

            for (PlcValue val : ((List<PlcValue>) values.getList())) {
                c_int16 value = (c_int16) val.getC_int16();
                /*TODO: migrate me*//*TODO: migrate me*/writeBuffer.writeShort("", 16, ((Number) (value)).shortValue());
            }

        } else if( EvaluationHelper.equals( dataType, ModbusDataType.DINT ) && EvaluationHelper.equals( numberOfValues, 1 ) ) { // DINT
            // Simple Field (value)
            c_int32 value = (c_int32) _value.getC_int32();
            /*TODO: migrate me*//*TODO: migrate me*/writeBuffer.writeInt("", 32, ((Number) (value)).intValue());
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.DINT ) ) { // List
            PlcList values = (PlcList) _value;

            for (PlcValue val : ((List<PlcValue>) values.getList())) {
                c_int32 value = (c_int32) val.getC_int32();
                /*TODO: migrate me*//*TODO: migrate me*/writeBuffer.writeInt("", 32, ((Number) (value)).intValue());
            }

        } else if( EvaluationHelper.equals( dataType, ModbusDataType.LINT ) && EvaluationHelper.equals( numberOfValues, 1 ) ) { // LINT
            // Simple Field (value)
            c_int64 value = (c_int64) _value.getC_int64();
            /*TODO: migrate me*//*TODO: migrate me*/writeBuffer.writeLong("", 64, ((Number) (value)).longValue());
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.LINT ) ) { // List
            PlcList values = (PlcList) _value;

            for (PlcValue val : ((List<PlcValue>) values.getList())) {
                c_int64 value = (c_int64) val.getC_int64();
                /*TODO: migrate me*//*TODO: migrate me*/writeBuffer.writeLong("", 64, ((Number) (value)).longValue());
            }

        } else if( EvaluationHelper.equals( dataType, ModbusDataType.USINT ) && EvaluationHelper.equals( numberOfValues, 1 ) ) { // USINT
            // Reserved Field
            /*TODO: migrate me*//*TODO: migrate me*/writeBuffer.writeUnsignedShort("", 8, ((Number) (c_uint8) 0x00).shortValue());
            // Simple Field (value)
            c_uint8 value = (c_uint8) _value.getC_uint8();
            /*TODO: migrate me*//*TODO: migrate me*/writeBuffer.writeUnsignedShort("", 8, ((Number) (value)).shortValue());
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.USINT ) ) { // List
            PlcList values = (PlcList) _value;

            for (PlcValue val : ((List<PlcValue>) values.getList())) {
                c_uint8 value = (c_uint8) val.getC_uint8();
                /*TODO: migrate me*//*TODO: migrate me*/writeBuffer.writeUnsignedShort("", 8, ((Number) (value)).shortValue());
            }

        } else if( EvaluationHelper.equals( dataType, ModbusDataType.UINT ) && EvaluationHelper.equals( numberOfValues, 1 ) ) { // UINT
            // Simple Field (value)
            c_uint16 value = (c_uint16) _value.getC_uint16();
            /*TODO: migrate me*//*TODO: migrate me*/writeBuffer.writeUnsignedInt("", 16, ((Number) (value)).intValue());
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.UINT ) ) { // List
            PlcList values = (PlcList) _value;

            for (PlcValue val : ((List<PlcValue>) values.getList())) {
                c_uint16 value = (c_uint16) val.getC_uint16();
                /*TODO: migrate me*//*TODO: migrate me*/writeBuffer.writeUnsignedInt("", 16, ((Number) (value)).intValue());
            }

        } else if( EvaluationHelper.equals( dataType, ModbusDataType.UDINT ) && EvaluationHelper.equals( numberOfValues, 1 ) ) { // UDINT
            // Simple Field (value)
            c_uint32 value = (c_uint32) _value.getC_uint32();
            /*TODO: migrate me*//*TODO: migrate me*/writeBuffer.writeUnsignedLong("", 32, ((Number) (value)).longValue());
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.UDINT ) ) { // List
            PlcList values = (PlcList) _value;

            for (PlcValue val : ((List<PlcValue>) values.getList())) {
                c_uint32 value = (c_uint32) val.getC_uint32();
                /*TODO: migrate me*//*TODO: migrate me*/writeBuffer.writeUnsignedLong("", 32, ((Number) (value)).longValue());
            }

        } else if( EvaluationHelper.equals( dataType, ModbusDataType.ULINT ) && EvaluationHelper.equals( numberOfValues, 1 ) ) { // ULINT
            // Simple Field (value)
            c_uint64 value = (c_uint64) _value.getC_uint64();
            /*TODO: migrate me*//*TODO: migrate me*/writeBuffer.writeUnsignedBigInteger("", 64, (BigInteger) (value));
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.ULINT ) ) { // List
            PlcList values = (PlcList) _value;

            for (PlcValue val : ((List<PlcValue>) values.getList())) {
                c_uint64 value = (c_uint64) val.getC_uint64();
                /*TODO: migrate me*//*TODO: migrate me*/writeBuffer.writeUnsignedBigInteger("", 64, (BigInteger) (value));
            }

        } else if( EvaluationHelper.equals( dataType, ModbusDataType.REAL ) && EvaluationHelper.equals( numberOfValues, 1 ) ) { // REAL
            // Simple Field (value)
            c_float value = (c_float) _value.getC_float();
            /*TODO: migrate me*//*TODO: migrate me*/writeBuffer.writeFloat("", 32,(value));
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.REAL ) ) { // List
            PlcList values = (PlcList) _value;

            for (PlcValue val : ((List<PlcValue>) values.getList())) {
                c_float value = (c_float) val.getC_float();
                /*TODO: migrate me*//*TODO: migrate me*/writeBuffer.writeFloat("", 32,(value));
            }

        } else if( EvaluationHelper.equals( dataType, ModbusDataType.LREAL ) && EvaluationHelper.equals( numberOfValues, 1 ) ) { // LREAL
            // Simple Field (value)
            c_double value = (c_double) _value.getC_double();
            /*TODO: migrate me*//*TODO: migrate me*/writeBuffer.writeDouble("", 64,(value));
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.LREAL ) ) { // List
            PlcList values = (PlcList) _value;

            for (PlcValue val : ((List<PlcValue>) values.getList())) {
                c_double value = (c_double) val.getC_double();
                /*TODO: migrate me*//*TODO: migrate me*/writeBuffer.writeDouble("", 64,(value));
            }

        } else if( EvaluationHelper.equals( dataType, ModbusDataType.CHAR ) && EvaluationHelper.equals( numberOfValues, 1 ) ) { // CHAR
            // Simple Field (value)
            str value = (str) _value.getStr();
            /*TODO: migrate me*//*TODO: migrate me*/writeBuffer.writeString("", 8, "UTF-8", (String) (value));
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.CHAR ) ) { // List
            PlcList values = (PlcList) _value;

            for (PlcValue val : ((List<PlcValue>) values.getList())) {
                str value = (str) val.getStr();
                /*TODO: migrate me*//*TODO: migrate me*/writeBuffer.writeString("", 8, "UTF-8", (String) (value));
            }

        } else if( EvaluationHelper.equals( dataType, ModbusDataType.WCHAR ) && EvaluationHelper.equals( numberOfValues, 1 ) ) { // WCHAR
            // Simple Field (value)
            str value = (str) _value.getStr();
            /*TODO: migrate me*//*TODO: migrate me*/writeBuffer.writeString("", 16, "UTF-16", (String) (value));
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.WCHAR ) ) { // List
            PlcList values = (PlcList) _value;

            for (PlcValue val : ((List<PlcValue>) values.getList())) {
                str value = (str) val.getStr();
                /*TODO: migrate me*//*TODO: migrate me*/writeBuffer.writeString("", 16, "UTF-16", (String) (value));
            }

        }
    }

    public static int getLengthInBytes(PlcValue _value, ModbusDataType dataType, c_uint16 numberOfValues) {
        return (int) Math.ceil((float) getLengthInBits(_value, dataType, numberOfValues) / 8.0);
    }

    public static int getLengthInBits(PlcValue _value, ModbusDataType dataType, c_uint16 numberOfValues) {
        int sizeInBits = 0;
if( EvaluationHelper.equals( dataType, ModbusDataType.BOOL ) && EvaluationHelper.equals( numberOfValues, 1 ) ) { // BOOL
                // Reserved Field
                sizeInBits += 15;
                // Simple Field (value)
                sizeInBits += 1;
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.BOOL ) ) { // List
                PlcList values = (PlcList) _value;
                sizeInBits += values.getList().size() * 1;
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.BYTE ) && EvaluationHelper.equals( numberOfValues, 1 ) ) { // BYTE
                // Reserved Field
                sizeInBits += 8;
                // Simple Field (value)
                sizeInBits += 8;
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.BYTE ) ) { // List
                PlcList values = (PlcList) _value;
                sizeInBits += values.getList().size() * 1;
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.WORD ) ) { // WORD
                // Simple Field (value)
                sizeInBits += 16;
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.DWORD ) ) { // DWORD
                // Simple Field (value)
                sizeInBits += 32;
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.LWORD ) ) { // LWORD
                // Simple Field (value)
                sizeInBits += 64;
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.SINT ) && EvaluationHelper.equals( numberOfValues, 1 ) ) { // SINT
                // Reserved Field
                sizeInBits += 8;
                // Simple Field (value)
                sizeInBits += 8;
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.SINT ) ) { // List
                PlcList values = (PlcList) _value;
                sizeInBits += values.getList().size() * 8;
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.INT ) && EvaluationHelper.equals( numberOfValues, 1 ) ) { // INT
                // Simple Field (value)
                sizeInBits += 16;
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.INT ) ) { // List
                PlcList values = (PlcList) _value;
                sizeInBits += values.getList().size() * 16;
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.DINT ) && EvaluationHelper.equals( numberOfValues, 1 ) ) { // DINT
                // Simple Field (value)
                sizeInBits += 32;
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.DINT ) ) { // List
                PlcList values = (PlcList) _value;
                sizeInBits += values.getList().size() * 32;
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.LINT ) && EvaluationHelper.equals( numberOfValues, 1 ) ) { // LINT
                // Simple Field (value)
                sizeInBits += 64;
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.LINT ) ) { // List
                PlcList values = (PlcList) _value;
                sizeInBits += values.getList().size() * 64;
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.USINT ) && EvaluationHelper.equals( numberOfValues, 1 ) ) { // USINT
                // Reserved Field
                sizeInBits += 8;
                // Simple Field (value)
                sizeInBits += 8;
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.USINT ) ) { // List
                PlcList values = (PlcList) _value;
                sizeInBits += values.getList().size() * 8;
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.UINT ) && EvaluationHelper.equals( numberOfValues, 1 ) ) { // UINT
                // Simple Field (value)
                sizeInBits += 16;
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.UINT ) ) { // List
                PlcList values = (PlcList) _value;
                sizeInBits += values.getList().size() * 16;
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.UDINT ) && EvaluationHelper.equals( numberOfValues, 1 ) ) { // UDINT
                // Simple Field (value)
                sizeInBits += 32;
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.UDINT ) ) { // List
                PlcList values = (PlcList) _value;
                sizeInBits += values.getList().size() * 32;
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.ULINT ) && EvaluationHelper.equals( numberOfValues, 1 ) ) { // ULINT
                // Simple Field (value)
                sizeInBits += 64;
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.ULINT ) ) { // List
                PlcList values = (PlcList) _value;
                sizeInBits += values.getList().size() * 64;
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.REAL ) && EvaluationHelper.equals( numberOfValues, 1 ) ) { // REAL
                // Simple Field (value)
                sizeInBits += 32;
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.REAL ) ) { // List
                PlcList values = (PlcList) _value;
                sizeInBits += values.getList().size() * 32;
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.LREAL ) && EvaluationHelper.equals( numberOfValues, 1 ) ) { // LREAL
                // Simple Field (value)
                sizeInBits += 64;
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.LREAL ) ) { // List
                PlcList values = (PlcList) _value;
                sizeInBits += values.getList().size() * 64;
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.CHAR ) && EvaluationHelper.equals( numberOfValues, 1 ) ) { // CHAR
                // Simple Field (value)
                sizeInBits += 8;
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.CHAR ) ) { // List
                PlcList values = (PlcList) _value;
                sizeInBits += values.getList().size() * 8;
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.WCHAR ) && EvaluationHelper.equals( numberOfValues, 1 ) ) { // WCHAR
                // Simple Field (value)
                sizeInBits += 16;
        } else if( EvaluationHelper.equals( dataType, ModbusDataType.WCHAR ) ) { // List
                PlcList values = (PlcList) _value;
                sizeInBits += values.getList().size() * 16;
        }
        return sizeInBits;
    }

}


